# -*- coding: utf-8 -*-
"""vrai_tp.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1DktF7ojHKokH5SNu8MCEzByww0R-j5U_
"""

import numpy as np
import matplotlib.pyplot as plt
import math

"""# Toit sous chargement

## Définition du problème

### Chargement
"""

f = -1 # charge répartie sur la poutre (constante, ne dépendant pas de x)
k = 0.1 # raideur de la poutre
nb_courbes = 20 # nombre de courbes qu'on veut visualiser sur le graphe

nb_courbes = 20

"""### Discrétisation en espace de la poutre"""

L = 1 # longueur de poutre
Nx = 100 # maillage de poutre à N points

X = np.linspace(0,L,Nx)

h = X[1]-X[0] # pas de discrétisation : espacement entre deux points de X

"""### Equation de la chaleur

On cherche à résoudre l'équation : 

$$-k\frac{\partial^2u}{\partial x^2} = f(x)$$

Pour ce faire on utilise une méthode de marche en temps avec l'équation de la chaleur : 

$$\frac{\partial U(x,t)}{\partial t}-k\frac{\partial^2U(x,t)}{\partial x^2} = f(x)$$

### Discretisation en temps du problème

pour des raisons de stabilité (à expliciter), on cherche à toujours vérifier l'inégalité : $$\frac{dt}{(dx)^2} \leq \frac{1}{2}$$ et donc à choisir des pas en conséquence.
"""

tf = 2 # durée d'observation
Nt = 4000 # Discrétisation du temps

dt = tf/Nt
choix = Nt/nb_courbes

choix = Nt/nb_courbes

"""### Etude de la déformation $U(x,t)$"""

U_app = np.zeros(len(X)) # déformée initialisée à déformation nulle sur l'ensemble de la poutre


RHS = np.zeros(len(X)) # on initialise le vecteur des incréments, il y en a un par point de X =^}

"""On va parcourir le temps et l'espace pour construire nos poutres temps après temps : (texte à trou, rester concentrée tout de même) Le but est juste de tracer les déformées et pouvoir bidouiller sur les paramètres."""

for n in range(0,Nt): # Parcours du temps jusqu'à tf
    
    if(n%choix==0):
        plt.plot(X,U_app)
        
    for i in range(1,Nx-1):
        
        RHS[i]=dt*(f+k*(U_app[i+1]+U_app[i-1]-2*U_app[i])/(h**2))
        
    for i in range(1,Nx-1):
        
        U_app[i] = U_app[i] + RHS[i]

"""### Améliorations en vu d'écrire l'erreur

**Un petit tips utile pour sortir d'une boucle for lorsqu'une certaine condition est vérifiée, par exemple, dans le plus grand des hasard des exemples théoriquements hypothétiques, métaphoriquement parlant bien sûr...**
"*L'instruction break permet de « casser » l'exécution d'une boucle ( while ou for ). Elle fait sortir de la boucle et passer à l'instruction suivante.*"
Exemple d'utilisation : si truc: break.
"""

def U_exacte(k,L,x):
    return (-x**2+L*x)/(2*k)

def norme_2(vecteur1,vecteur2):
    s = 0
    for i in range(len(vecteur1)):
        s = s + abs(vecteur1[i] - vecteur2[i])**2
    return math.sqrt(s)

f = -1 # charge répartie sur la poutre (constante, ne dépendant pas de x)
k = 0.1 # raideur de la poutre
L = 1 # longueur de poutre
Nx = 100 # maillage de poutre à N points
X = np.linspace(0,L,Nx)
h = X[1]-X[0] # pas de discrétisation : espacement entre deux points de X
tf = 16 # durée d'observation
Nt = 32000 # Discrétisation du temps
dt = tf/Nt
U_app = np.zeros(len(X)) # déformée initialisée à déformation nulle sur l'ensemble de la poutre
RHS = np.zeros(len(X)) # on initialise le vecteur des incréments, il y en a un par point de X =^}

nb_iter = 0
eps = 0.000001

for n in range(0,Nt): # Parcours du temps jusqu'à tf
    
    for i in range(1,Nx-1):
        
        RHS[i]=dt*(f+k*(U_app[i+1]+U_app[i-1]-2*U_app[i])/(h**2))
        
        
    if(norme_2(U_app + RHS,U_app) < eps):
        break
        
    for i in range(1,Nx-1):
        
        U_app[i] = U_app[i] + RHS[i]

        
    nb_iter = nb_iter + 1
    
print(nb_iter)

U_app

U_exacte(k,L,X)

"""### Code de l'erreur"""

f = -1 # charge répartie sur la poutre (constante, ne dépendant pas de x)
k = 0.1 # raideur de la poutre
L = 1 # longueur de poutre
Nx = 100 # maillage de poutre à N points
X = np.linspace(0,L,Nx)
h = X[1]-X[0] # pas de discrétisation : espacement entre deux points de X
tf = 16 # durée d'observation
Nt = 32000 # Discrétisation du temps
dt = tf/Nt
U_app = np.zeros(len(X)) # déformée initialisée à déformation nulle sur l'ensemble de la poutre
RHS = np.zeros(len(X)) # on initialise le vecteur des incréments, il y en a un par point de X =^}

N = np.arange(3,40,1)
Erreur = np.zeros (len(N))
DX = np.zeros (len(N))
dx = L/(Nx-1)

for m in range(0,len(N)):

    for n in range(0,Nt):
    
        for i in range(1,Nx-1):
        
            RHS[i]=dt*(f+k*(U_app[i+1]+U_app[i-1]-2*U_app[i])/(h**2))
        
        for i in range(1,Nx-1):
            
            U_app[i] = U_app[i] + RHS[i]
            
    DX[m]=dx
    Erreur [m] = norme_2(U_exacte(k,L,X), U_app)



